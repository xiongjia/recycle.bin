%title Shell
%toc

俺覺得 Shell Script 的主要難點是需要較廣的知識面。
有時會與不會只是對於某個 command 的了解與否。 <br>
(比如: 不了解 `tail` , `head` 等就不能方便的讀取行。
不了解 `pgrep` 不能方便的查找 process。)

大概也就多參考別人寫的，自己多練才會慢慢進步吧(??)。
所以這裡大概記錄些遇到過的知識。

-----

= Resources =
* awesome-shell - github 上別人歸檔的 Shell 資料: https://github.com/alebcay/awesome-shell
* leetcode 中 Shell 分類的題目: https://leetcode.com/problemset/shell/
  - 我當時的解法: http://xiongjia.github.io/dev/2015/06/23/shell-problems/ 
* <The Linux Command Line> - 中、英語版: https://github.com/billie66/TLCL
* <Advanced Bash-Scripting Guide> - http://tldp.org/LDP/abs/html/index.html

== Tips ==
=== 并行执行 ===
Shell Script 的主要工作基本都是去調用各個 commands 去完成的。<br>
所以如果能讓這些 commands 並行執行是會非常有助於提高效率的。

完成这一個工作需要用到 `wait` command。 <br>
比如下面這個例子: 用 2 條加了 `&` 的 `sleep` commands 表示 2 個任務。
`wait` 沒有參數表示等待 2 個 `sleep` 都結束。`sleep` 只是個例子，
也可以是從網上下載數據或是其他操作。由於並行執行所以應該會快出很多。
{{{class="brush: shell; gutter: false; toolbar: false;"
#!/bin/sh
sleep 100 &
sleep 200 &
wait
}}}

也可以讓 `wait` 只等待某一個任務結束。 <br>
比如下面這個例子, `$!` 表示第一個 `sleep` 的 process id。加在 `wait` 的參數裏表示只等待
某個 process。這 shell script 應該在 100 秒后退出而，第二個 `sleep` 在 script 退出時還在運行。
{{{class="brush: shell; gutter: false; toolbar: false;"
#!/bin/sh
sleep 100 &
first_sleep=$!
sleep 1000 &
wait ${first_sleep}
}}}

舉一個實際工作中的簡單例子。copy 比較大的 files。如果正常 copy 是一個完成后再另一個。
可以多個文件同時 copy 最大程度的發揮出 disk 的 I/O 吞吐量。 <br>
比如下面這個例子，從一個列表裏讀出源，執行 `cp`，最後在用 `wait` 等待所有 copy 任務結束:
{{{class="brush: shell; gutter: false; toolbar: false;"
#!/bin/sh

dest=/your_dest_folder

for file in "bigfile1" "bigfile2" "bigfile3"
do
    cp -v "${file}" "${dest}" &
done
wait
}}}

=== json parser ===
有很多的 configuration file 多用 JSON 格式。在 Shell script 裏有時也需要讀取這些配置的值。<br>
比如下面這個例子，通過 `node` 來的到 .json file 裏面某個字段的值。
如果 JSON 内容是 {"port": 8080 } 則 `PORT` 會賦為 "8080"。
但如果 JSON 内容文件有誤，則 `PORT` 會是 "undefined"。
{{{class="brush: shell; gutter: false; toolbar: false;"
#!/bin/sh
src_json_file=/your_json_filename

# In this sample, the JSON content = { "port": 8080 }
PORT=`node -pe "JSON.parse(process.argv[1]).port" "$(cat ${src_json_file})"`
echo "Your port is ${PORT}"
}}}

除了 `node` 外，也有其它的 command line json tools, 只是這些一般情況需要安裝(非默認安裝)。比如:
- jq: https://stedolan.github.io/jq/
- jsawk: https://github.com/micha/jsawk

=== command options ===
實際的 shell script 有時需要從 command options 裏讀取參數，例如: `./test.sh -c config_file -d` 
( `-c` 表示配置文件; `-d` 表示調試方式 )

在 shell script 裏可以用 `getopts` 操作來解析這些 options。比如下面這個例子:
{{{class="brush: shell; gutter: false; toolbar: false;"
#!/bin/sh

conf_file=/your_default_conf_file
debug_flag=false

while getopts "c:d" opt; do
    case "$opt" in
    c)
        conf_file=${OPTARG}
        ;;
    d)
        debug_flag=true
        ;;
    esac
done

echo "conf_file  = ${conf_file}"
echo "debug_flag = ${debug_flag}"
}}}

`getopts` 的基本用法是 `getopts OPTSTRING VARNAME [ARGS]`。
- `OPTSTRING` - 這個等同于 GNU getopt 裏的用法, 比如 "c:d" 有 ":" 的表示有參數。
  "-c config_file" 中的 config_file 就是參數可以從 `OPTARG` 裏讀取。
- `VARNAME` - 表示 option 的變量名
- `ARGS` - 代表參數列表，默認是 `$@`  (即 shell script 的 command options )

=== 減少不必要的 Fork ===
列幾點平時用的到的減少不必要 fork 的方法:
* 減少不必要的 command
  盡量挖掘 command 自身的功能，如無必要則不使用多餘的 command。比如:
  - `cat <file> | grep <pattern>` - 因爲 `cat` 是多餘的
  - `grep <pattern> <file>` - 比之前好，因爲減少了不必要的 `cat` 和用 pipe 傳送數據的開銷。
* 字符串處理<br>
  字符串處理時盡量多用 shell 自帶的操作。如果只是一兩字符串的操作用處也不大，
  只是有些循環中的字符串操作用此改進就會有較大的意義了。
  比如字符串替換: (更多 strings 操作，列在了本頁裏的 strings section 裏了):
  - 用了 `tr` 刪除所有數字
{{{class="brush: shell; gutter: false; toolbar: false;"
src_str=123abc
echo "${src_str}" |  tr -d   "[:digit:]"
}}}
  - 省去 `tr` ，用如下操作可達到同樣效果:
{{{class="brush: shell; gutter: false; toolbar: false;"
src_str=123abc
echo "${src_str//[0-9]/}"
}}}
  - `sed`, `awk`, `tr` 等都是很強的文本操作，如果不是必須，就不要用。

* `[` vs `[[` <br>
  `[` 和 `[[` 都可以用作 shell script 的表達式判斷。區別在於:
  - `[` 其實是一個 command 會有一次 fork。`[[` 是 shell 内部操作不需要 fork 一個 process。
  - `[[` 並不是 posix 標準，默認 shell 可能不支持。但是 bash 肯定是支持的。
    所以在用 `[[` 時應該把 `.sh` 的第一行 (hashbang) 改爲 `#!/bin/bash`。
 
=== strings ===
雖然用 `tr`, `sed` , `awk` 等工具可以完成大量複雜的文本操作，
不過爲了減少不必要的 fork 内部能完成的操作就不要借助這些工具了。
(尤其是像在一些 `while` loop 裏執行的字符串操作, 減少 fork 一定會獲益良多.)
比如下面這些基本的字符串操作:
- 引用,基本用法的，如下面的例子:
  * 例子中 `${var-DEFAULT}` 表示: 在 var 無定義時用 DEFAULT 替代 
    ( `${var=DEFAULT}` 可以達到同樣效果 )
  * 例子中 `${var:-DEFAULT}` 表示: 在 var 無定義或為空時用 DEFAULT 替代 
    (`${var:=DEFAULT}` 可以達到同樣效果)
  * 例子中 `${var+OTHER}` 表示: 在 var 被定義時用 OTHER 取代,否則為空
  * 例子中 `${var:+OTHER}` 表示: 在 var 不為空時用 OTHER 取代,否則為空
  * 例子中 `${!var_prefix*}` 表示: 所有 "var_prefix" 開始的 var names 
    ( `${!var_prefix@}` 可以達到同樣效果 )
{{{class="brush: shell; gutter: false; toolbar: false;"
#!/bin/sh

test_str="123"
empty_str=""

echo "Test String is ${test_str}"                # output => Test String is 123
echo "Test string is ${unknown_str-DefaultVal}"  # output => Test String is DefaultVal
echo "Test string is ${empty_str:-EmptyVal}"     # output => Test String is EmptyVal

echo "Test string is ${test_str+AnotherStr}"     # output => Test string is AnotherStr
echo "Test string is ${unknown_str+AnotherStr}"  # output => Test string is 
echo "Test string is ${empty_str+AnotherStr}"    # output => Test string is AnotherStr

echo "Test string is ${test_str:+AnotherStr}"     # output => Test string is AnotherStr
echo "Test string is ${unknown_str:+AnotherStr}"  # output => Test string is 
echo "Test string is ${empty_str:+AnotherStr}"    # output => Test string is 

test_var1="123"
test_var2="456"
_test_var3="789"
echo "Test Vars are ${!test_var*}"    # output => Test Vars are test_var1 test_var2
}}}
  * 另外還有些有用的操作:
    * `${var?MESSAGE}` 表示: 在 var 無定義時，輸出 MESSAGE
    * `${var:?MESSAGE}` 表示: 在 var 無定義或為空時，輸出 MESSAGE
- 字符长度计算，基本用法 `${#var}`
 * 比如下面這個例子，顯示字符串長度:
{{{
test_str="abc"
echo "String length is ${#test_str}"  # output => String length is 3
}}}
- 子串引用，基本用法: `${string:position:length}`
 * position 從 0 開始計數
 * position 可以為負數，表示倒數第幾個開始
 * 比如下面幾個例子，右面註釋是輸出結果,注意:
{{{
test_str="0123456789"
echo "Sub string: ${test_str:2}"      # output=> 23456789
echo "Sub string: ${test_str:2:5}"    # output=> 23456
echo "Sub string: ${test_str:(-5)}"   # output=> 56789
echo "Sub string: ${test_str:(-5):2}" # output=> 56
}}}
- 字符串替換
 * 基本用法:
   - `${string/substring or pattern/replacement}`
   - `${string//substring or pattern/replacement}`
   - `${string/#substring or pattern/replacement}`
   - `${string/%substring or pattern/replacement}`
 * 這些操作的格式大致是一樣的，變量/被替換的字串 或 被替換字串的表達式/替換成的字符串。
 * 幾個操作的第一個 '/' 後面相當於一個 flag, 表示替換的方式。
   - '/' : 表示替換第一個符合條件的
   - '//': 表示替換所有符合條件的
   - '/#': 符合條件並且在字符串的開頭
   - '/%': 符合條件並且在字符串的結尾
 * 比如下面這些個例子,右面的註釋是輸出結果:
{{{
test_str="12345678abc12345"
# substring replacement
echo "Replace first 123 to ---: ${test_str/123/---}"   # output=> ---45678abc12345
echo "Replace all 123 to ---: ${test_str//123/---}"    # output=> ---45678abc---45
echo "Replace prefix 123 to ---: ${test_str/#123/---}" # output=> ---45678abc12345
echo "Replace prefix 456 to ---: ${test_str/#456/---}" # output=> 12345678abc12345
echo "Replace suffix 345 to ---: ${test_str/%345/---}" # output=> 12345678abc12---
echo "Replace suffix 123 to ---: ${test_str/%123/---}" # output=> 12345678abc12345

# pattern replacement
echo "Replace first number to -: ${test_str/[0-9]/-}"  # output=> -2345678abc12345
echo "Replace all numbers to -: ${test_str//[0-9]/-}"  # output=> --------abc-----
echo "Remove first number: ${test_str/[0-9]/}"         # output=> 2345678abc12345
echo "Remove all numbers: ${test_str//[0-9]/}"         # output=> abc
}}}

